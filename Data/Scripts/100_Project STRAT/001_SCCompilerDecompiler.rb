###############################################################################
# SCCompilerDecompiler
# 
# This script is part of Pokémon Project STRAT by StCooler, and is therefore 
# not part of Pokémon Essentials. 
# 
# This script contains everything related to the compilation and decompilation 
# of the datasets specific to Pokémon Project STRAT. 
# Note that all the PBS files mentionned here are generated by a Python script 
# that I won't share with the game (but you can ask me if you want).
# 
# -----------------------------------------------------------------------------
# Database of patterns: 
#   Compilation of PBS/scmvstpatterns.txt
#   Decompilation (pattern names are stored in MessageTypes). 
# Each moveset type is identified by a SCMovesetPatterns constant, for later 
# use in the generation of movesets in the Team Builder. 
# 
# -----------------------------------------------------------------------------
# Database of movesets: 
#   Compilation of PBS/scmovesets.txt
#   Decompilation of Data/scmovesets.dat
# Each Pokémon has a set of movesets, to be used by NPCs in random battle, or 
# by the player who doesn't want to spend time making a team.
# Compiled for faster acces later.
# 
# -----------------------------------------------------------------------------
# Database of movepools:
#   Compilation of PBS/sclearned.txt
#   Decompilation of Data/sclearned.dat and Data/scstattotals.dat
# Each Pokémon is associated with the list of moves it can learn. This is 
# faster than checking the pokemon data + tm.dat and such in order to gather 
# the movepool of a given Pokémon. Used in Teambuilder, in the move selection.
# Compiled for faster acces later.
# The stat total is used in very big tiers, to rank Pokémons by base stats, 
# and avoid having Dunsparce in the same team as Tyranitar in FE. 
# 
# -----------------------------------------------------------------------------
# Database of tiers:
#   Compilation of PBS/sctiers.txt
#   Decompilation of Data/sctiers.dat
# Description of tiers of Pokémons. Note that these tiers are different to the 
# one from Smogon/Showdown.
# Compiled for faster acces later.
# 
# -----------------------------------------------------------------------------
# Database of personal items:
#   Compilation of PBS/scpersonalitems.txt
#   Decompilation of Data/scpersonalitems.dat
# Description of personal items: items that work only with a given Pokémon 
# (e.g. Mega-Stones, or Thick Club for Marowak).
# Compiled for faster acces later.
# 
###############################################################################





def scCompilePatterns
  records  = []
  patterns = []
  maxValue = 0
  pbCompilerEachPreppedLine("PBS/scmvstpatterns.txt") { |line,lineno|
    record = pbGetCsvRecord(line,lineno,[0,"vns"])
    if patterns[record[0]]
      raise _INTL("Pattern ID number '{1}' is used twice.\r\n{2}",record[0],FileLineData.linereport)
    end
    patterns[record[0]] = record[2]
    maxValue = [maxValue,record[0]].max
    records.push(record)
  }
  MessageTypes.setMessages(MessageTypes::MovesetPatterns,patterns)
  code = "class SCMovesetPatterns\r\n"
  for rec in records
    code += "#{rec[1]}=#{rec[0]}\r\n"
  end
  code += "def self.getName(id)\r\n"
  code += "id=getID(SCMovesetPatterns,id)\r\n"
  code += "return pbGetMessage(MessageTypes::MovesetPatterns,id); end\r\n"
  code += "def self.getCount; return #{records.length}; end\r\n"
  code += "def self.maxValue; return #{maxValue}; end\r\n"
  code += "end\r\n"
  eval(code)
  pbAddScript(code,"SCMovesetPatterns")
end



def scSavePatterns
  File.open("PBS/scmvstpatterns.txt","wb") { |f|
    # f.write(0xEF.chr)
    # f.write(0xBB.chr)
    # f.write(0xBF.chr)
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    f.write("\#-------------------------------\r\n")
    for i in 1..(SCMovesetPatterns.maxValue rescue SCMovesetPatterns.getCount-1 rescue pbGetMessageCount(MessageTypes::MovesetPatterns)-1)
      abilname = getConstantName(SCMovesetPatterns,i) rescue pbGetAbilityConst(i)
      next if !abilname || abilname==""
      name = pbGetMessage(MessageTypes::MovesetPatterns,i)
      next if !name || name==""
      f.write(sprintf("%d,%s,%s\r\n",i,csvQuote(abilname),csvQuoteAlways(name)))
    end
  }
end



def scGetMovesetPatternConst(i)
  return MakeshiftConsts.get(MessageTypes::MovesetPatterns,i,SCMovesetPatterns)
end




#===============================================================================
# Compile/decompile movesets
#===============================================================================

module SCMovesetsData
  # Note that these constants will also be used in SCTeamBuilder, whose goal is 
  # to manipulate Arrays indexed by these constants. 
  SPECIES = 0 
  FORM = 1 
  ITEM = 2 
  MOVE1 = 3
  MOVE2 = 4
  MOVE3 = 5
  MOVE4 = 6
  ABILITYINDEX = 7
  GENDER = 8 
  NATURE = 9
  EV = 10
  IV = 11
  ROLE = 12
  SHINY = 13
  HAPPINESS = 14
  BALL = 15
  LEVEL = 16
  BASEFORM = 17 # If a Pokémon has two forms, and each form has a Mega (0 -> 1 / 2 -> 3)
  NICKNAME = 18
  FSPECIES = 19
  FORMNAME = 20
  BASESPECIES = 21 # If a Pokémon has two forms, and each form has a Mega (0 -> 1 / 2 -> 3)
  ABILITY = 22
  PATTERN = 23
  MAXINDEX = 23
  
  MovesIndices = {MOVE1 => "Move1", MOVE2 => "Move2", MOVE3 => "Move3", MOVE4 => "Move4"}
  MovesIndicesList = [MOVE1, MOVE2, MOVE3, MOVE4]
  
  
  def self.validRole(role)
    for i in 1..4
      # LEAD = 1
      # OFFENSIVE = 2
      # DEFENSIVE = 3
      # SUPPORT = 4
      for j in 0..3
        # PHYSICAL = 1 
        # SPECIAL = 2
        # MIXED = 3
        return true if role == i*10 + j
      end
    end
    return false 
  end 
  
  
  def self.newEmpty()
    return Array.new(MAXINDEX)
  end 
  
  
  def self.newEmpty2(speciesid = nil)
    # Note that this function is also used in SCTeamBuilder, as a base. 
    moveset = self.newEmpty()
    
    if speciesid
      sp = pbGetSpeciesFromFSpecies(speciesid)
      moveset[SPECIES] = sp[0]
      moveset[FORM] = sp[1]
      moveset[BASEFORM] = sp[1]
      moveset[FSPECIES] = speciesid
      moveset[BASESPECIES] = speciesid
    end 
    
    moveset[EV] = Array.new(6, 0)
    moveset[IV] = Array.new(6, 31)
    
    return moveset
  end 
  
  
  InfoTypes = {
    "Pokemon"   => [SPECIES,   "ev", :PBSpecies,nil],   # Species, level
    "Form"      => [FORM,      "u"],
    "BaseForm"  => [BASEFORM,  "u"],
    "Item"      => [ITEM,      "*e", :PBItems], # Several potential items for the moveset
    "Move1"     => [MOVE1,     "*e", :PBMoves], # Several potneitla moves for the moveset 
    "Move2"     => [MOVE2,     "*e", :PBMoves], 
    "Move3"     => [MOVE3,     "*e", :PBMoves],
    "Move4"     => [MOVE4,     "*e", :PBMoves],
    "Ability"   => [ABILITYINDEX,   "u"],
    "Gender"    => [GENDER,    "e", { "M" => 0, "m" => 0, "Male" => 0, "male" => 0, "0" => 0,
                                      "F" => 1, "f" => 1, "Female" => 1, "female" => 1, "1" => 1 }],
    "Shiny"     => [SHINY,     "b"],
    "Nature"    => [NATURE,    "e", :PBNatures],
    "Nature1"   => [NATURE,    "e", :PBNatures],
    "Nature2"   => [NATURE,    "e", :PBNatures],
    "Nature3"   => [NATURE,    "e", :PBNatures],
    "Nature4"   => [NATURE,    "e", :PBNatures],
    "Nature5"   => [NATURE,    "e", :PBNatures],
    "Nature6"   => [NATURE,    "e", :PBNatures],
    "Nature7"   => [NATURE,    "e", :PBNatures],
    "Nature8"   => [NATURE,    "e", :PBNatures],
    "Nature9"   => [NATURE,    "e", :PBNatures],
    "IV"        => [IV,        "uUUUUU"],
    "Happiness" => [HAPPINESS, "u"],
    "Ball"      => [BALL,      "u"],
    "EV"        => [EV,        "uUUUUU"],
    "EV1"       => [EV,        "uUUUUU"],
    "EV2"       => [EV,        "uUUUUU"],
    "EV3"       => [EV,        "uUUUUU"],
    "EV4"       => [EV,        "uUUUUU"],
    "EV5"       => [EV,        "uUUUUU"],
    "EV6"       => [EV,        "uUUUUU"],
    "EV7"       => [EV,        "uUUUUU"],
    "EV8"       => [EV,        "uUUUUU"],
    "EV9"       => [EV,        "uUUUUU"],
    "Role"      => [ROLE,      "u"],
    "Pattern"   => [PATTERN,   "e",  :SCMovesetPatterns],
    "Name"      => [NICKNAME,  "s"]
  }
  
end 



def scCompileMovesets
  mLevel = PBExperience.maxLevel
  trainerindex    = -1
  trainers        = []
  pokemonindex    = -2
  movesets        = {}
  moveset         = SCMovesetsData.newEmpty()
  moveset_natures = []
  moveset_ev_spreads = []
  pokemon_id      = -1 
  # movesets: species_id -> list of lists of values
  #                                 vvvvvvvvvvvvvvv
  #                                 List of values encoding the moveset. 
  pbCompilerEachCommentedLine("PBS/scmovesets.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/scmovesets.txt (line {1})...",lineno))
    end

    if line[/^\s*(\w+)\s*=\s*(.*)$/]
      # XXX=YYY lines
      settingname = $~[1]
      schema = SCMovesetsData::InfoTypes[settingname]
      next if !schema
      record = pbGetCsvRecord($~[2],lineno,schema)
      # Error checking in XXX=YYY lines
      case settingname
      when "Pokemon"
        if record[1]>mLevel
          raise _INTL("Bad level: {1} (must be 1-{2})\r\n{3}",record[1],mLevel,FileLineData.linereport)
        end
        if pokemon_id > 0
          # Then new moveset. Store the current moveset. 
          moveset[SCMovesetsData::NATURE] = moveset_natures if moveset_natures.length > 0 
          moveset[SCMovesetsData::EV] = moveset_ev_spreads if moveset_ev_spreads.length > 0 
          moveset[SCMovesetsData::PATTERN] = 1 if !moveset[SCMovesetsData::PATTERN]
          
          moveset[SCMovesetsData::SPECIES] = pokemon_id
          moveset[SCMovesetsData::BASESPECIES] = pokemon_id if !moveset[SCMovesetsData::BASESPECIES]
          
          if movesets[pokemon_id]
            movesets[pokemon_id].push(moveset)
          else 
            movesets[pokemon_id] = [moveset]
          end 
          
          moveset         = SCMovesetsData.newEmpty()
          moveset_natures = []
          moveset_ev_spreads = []
        end 
        pokemon_id = record[0]
        moveset[SCMovesetsData::LEVEL] = record[1]
      when "Move1", "Move2", "Move3", "Move4"
        record = [record] if record.is_a?(Integer)
        record.compact!
      when "Ability"
        if record>5
          raise _INTL("Bad ability flag: {1} (must be 0 or 1 or 2-5).\r\n{2}",record,FileLineData.linereport)
        end
      when "IV"
        record = [record] if record.is_a?(Integer)
        record.compact!
        for i in record
          next if i<=PokeBattle_Pokemon::IV_STAT_LIMIT
          raise _INTL("Bad IV: {1} (must be 0-{2})\r\n{3}",i,PokeBattle_Pokemon::IV_STAT_LIMIT,FileLineData.linereport)
        end
      when "EV", "EV1", "EV2", "EV3", "EV4", "EV5", "EV6", "EV7", "EV8", "EV9"
        record = [record] if record.is_a?(Integer)
        record.compact!
        for i in record
          next if i<=PokeBattle_Pokemon::EV_STAT_LIMIT
          raise _INTL("Bad EV: {1} (must be 0-{2})\r\n{3}",i,PokeBattle_Pokemon::EV_STAT_LIMIT,FileLineData.linereport)
        end
        evtotal = 0
        for i in 0...6
          evtotal += (i<record.length) ? record[i] : record[0]
        end
        if evtotal>PokeBattle_Pokemon::EV_LIMIT
          raise _INTL("Total EVs are greater than allowed ({1})\r\n{2}",PokeBattle_Pokemon::EV_LIMIT,FileLineData.linereport)
        end
        moveset_ev_spreads.push(record)
      when "Nature", "Nature1", "Nature2", "Nature3", "Nature4", "Nature5", "Nature6", "Nature7", "Nature8", "Nature9"
        moveset_natures.push(record)
      when "Happiness"
        if record>255
          raise _INTL("Bad happiness: {1} (must be 0-255)\r\n{2}",record,FileLineData.linereport)
        end
      when "Role"
        if !SCMovesetsData.validRole(record)
          raise _INTL("Bad moveset role: {1} (must be integer X*10 + Y, X=1..4 and Y=1..3)\r\n{2}",record,FileLineData.linereport)
        end 
      when "Form"
        moveset[SCMovesetsData::BASESPECIES] = pokemon_id
        pokemon_id = pbGetFSpeciesFromForm(pokemon_id, record)
      # when "BaseForm"
        # pokemon_id = pbGetFSpeciesFromForm(pokemon_id, record)
        # moveset[SCMovesetsData::BASESPECIES] = pokemon_id
      end
      if schema[0] <= SCMovesetsData::MAXINDEX
        moveset[schema[0]] = record
      end 
    end
  }
  if pokemon_id > 0
    # Last moveset. 
    moveset[SCMovesetsData::NATURE] = moveset_natures if moveset_natures.length > 0 
    moveset[SCMovesetsData::EV] = moveset_ev_spreads if moveset_ev_spreads.length > 0 
    moveset[SCMovesetsData::SPECIES] = pokemon_id
    moveset[SCMovesetsData::BASESPECIES] = pokemon_id if !moveset[SCMovesetsData::BASESPECIES]
    
    if movesets[pokemon_id]
      movesets[pokemon_id].push(moveset)
    else 
      movesets[pokemon_id] = [moveset]
    end 
  end 
  save_data(movesets,"Data/scmovesets.dat")
end



def scSaveMovesets
  data = scLoadMovesetsData
  
  return if !data 
  File.open("PBS/scmovesets.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    total_movesets = data.keys.length
    processed = 0

    # data.each_pair { |poke, movesets|
    for poke in 1..PBSpecies.maxValueF
      processed += 1 
      
      if processed%5==0
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing moveset {1}/{2}...",processed, total_movesets))
      end
      
      movesets = data[poke]
      
      next if !movesets && poke > PBSpecies.maxValue
      
      f.write("\#-------------------------------\r\n")
      for moveset in movesets
        f.write(scConvertMovesetToString(moveset, true))
      end 
    end
  }
end



def scLoadMovesetsData
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/scmovesets.dat")
end



def scConvertMovesetToString(moveset, with_tab = false, for_compiler = true)
  s_tab = (with_tab ? "    " : "")
  
  # Pokemon species + form
  poke1 = pbGetSpeciesFromFSpecies(moveset[SCMovesetsData::SPECIES])
  species = getConstantName(PBSpecies,poke1[0]) #rescue pbGetSpeciesConst(poke1[0]) rescue ""
  
  s = _INTL("Pokemon = {1},{2}\r\n", species, moveset[SCMovesetsData::LEVEL])
  
  if moveset[SCMovesetsData::FORM] && for_compiler
    s += sprintf(s_tab + "Form = %d\r\n",moveset[SCMovesetsData::FORM])
  end
  if moveset[SCMovesetsData::BASEFORM]
    s += sprintf(s_tab + "BaseForm = %d\r\n",moveset[SCMovesetsData::BASEFORM]) if for_compiler
    s += sprintf(s_tab + "Form = %d\r\n",moveset[SCMovesetsData::BASEFORM]) if !for_compiler
  end 
  
  # Item(s)
  if moveset[SCMovesetsData::ITEM]
    if moveset[SCMovesetsData::ITEM].is_a?(Array)
      item = "" 
      for i in 0...moveset[SCMovesetsData::ITEM].length
        itemname = getConstantName(PBItems,moveset[SCMovesetsData::ITEM][i]) rescue pbGetItemConst(moveset[SCMovesetsData::ITEM][i]) rescue nil
        next if !itemname
        item.concat(", ") if i>0
        item.concat(itemname)
      end 
      s += sprintf(s_tab + "Item = %s\r\n",item) if item
      
    else 
      s += sprintf(s_tab + "Item = %s\r\n",getConstantName(PBItems,moveset[SCMovesetsData::ITEM]))
    end 
  end
  
  # Move(s)
  if for_compiler
    for move_i in SCMovesetsData::MovesIndicesList
      move_s = SCMovesetsData::MovesIndices[move_i]
      if moveset[move_i] 
        if moveset[move_i].is_a?(Array)
          movestring = ""
          for i in 0...moveset[move_i].length
            movename = getConstantName(PBMoves,moveset[move_i][i]) rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
            next if !movename
            movestring.concat(", ") if i>0
            movestring.concat(movename)
          end
          s += sprintf(s_tab + "" + move_s + " = %s\r\n",movestring) if movestring!=""
          
        else 
          s += sprintf(s_tab + "" + move_s + " = %s\r\n",getConstantName(PBMoves,moveset[move_i]))
        end 
      end
    end
  else 
    moves_s = "Moves = "
    
    for move_i in SCMovesetsData::MovesIndicesList
      next if !moveset[move_i]
      moves_s += ", " if move_i > SCMovesetsData::MOVE1
      moves_s += getConstantName(PBMoves,moveset[move_i])
    end 
    
    s += sprintf(s_tab + moves_s)
  end 
  
  # Ability 
  if moveset[SCMovesetsData::ABILITYINDEX]
    s += sprintf(s_tab + "Ability = %d\r\n",moveset[SCMovesetsData::ABILITYINDEX])
  end
  
  # Nature 
  if moveset[SCMovesetsData::NATURE]
    if moveset[SCMovesetsData::NATURE].is_a?(Array)
      for i in 0...moveset[SCMovesetsData::NATURE].length
        nature = getConstantName(PBNatures,moveset[SCMovesetsData::NATURE][i]) rescue nil
        s += sprintf(s_tab + "Nature%d = %s\r\n",i+1, nature) if nature
      end
    else 
      s += sprintf(s_tab + "Nature1 = %s\r\n", getConstantName(PBNatures,moveset[SCMovesetsData::NATURE]))
    end 
  end
  
  if moveset[SCMovesetsData::EV] && moveset[SCMovesetsData::EV].length>0
    
    if moveset[SCMovesetsData::EV][0].is_a?(Array) || for_compiler
      ev_i = 1 
      for ev_spread in moveset[SCMovesetsData::EV]
        s += sprintf(s_tab + "EV%d = %d",ev_i, ev_spread[0])
        if ev_spread.length>1
          for i in 1...6
            s += sprintf(",%d",(i<ev_spread.length) ? ev_spread[i] : ev_spread[0])
          end
        end
        s += "\r\n"
        ev_i += 1 
      end 
    else 
      s += sprintf(s_tab + "EV = %d", moveset[SCMovesetsData::EV][0])
      for i in 1...6
        s += sprintf(",%d",moveset[SCMovesetsData::EV][i])
      end
    end 
  end
  
  if moveset[SCMovesetsData::IV] && moveset[SCMovesetsData::IV].length>0
    s += sprintf(s_tab + "IV = %d",moveset[SCMovesetsData::IV][0])
    if moveset[SCMovesetsData::IV].length>1
      for i in 1...6
        s += sprintf(",%d",(i<moveset[SCMovesetsData::IV].length) ? moveset[SCMovesetsData::IV][i] : moveset[SCMovesetsData::IV][0])
      end
    end
    s += "\r\n"
  end
  
  if moveset[SCMovesetsData::GENDER]
    s += sprintf(s_tab + "Gender = %s\r\n",(moveset[SCMovesetsData::GENDER]==1) ? "Female" : "Male")
  end
  if moveset[SCMovesetsData::SHINY]
    s += s_tab + "Shiny = yes\r\n"
  end
  if moveset[SCMovesetsData::HAPPINESS] && moveset[SCMovesetsData::HAPPINESS] != 255
    s += sprintf(s_tab + "Happiness = %d\r\n",moveset[SCMovesetsData::HAPPINESS])
  end
  if moveset[SCMovesetsData::BALL]
    s += sprintf(s_tab + "Ball = %d\r\n",moveset[SCMovesetsData::BALL])
  end
  if moveset[SCMovesetsData::ROLE] && for_compiler
    s += sprintf(s_tab + "Role = %d\r\n",moveset[SCMovesetsData::ROLE])
  end
  if moveset[SCMovesetsData::PATTERN] && moveset[SCMovesetsData::PATTERN] != SCMovesetPatterns::NOPATTERN && for_compiler
    s += sprintf(s_tab + "Pattern = %s\r\n",getConstantName(SCMovesetPatterns, moveset[SCMovesetsData::PATTERN]))
  end
	
	return s 
end 






#===============================================================================
# Compile/decompile learned moves
#===============================================================================

def scCompileLearnedMoves
  movepool = {}
  stats = {}
  pbCompilerEachCommentedLine("PBS/sclearned.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/sclearned.txt (line {1})...",lineno))
    end
    if line[/^\s*(\w+)\s*=\s*(\d+)\s*,\s*(.*)$/]
      poke = pbGetCsvRecord($~[1],lineno,[0, "e", :PBSpecies])
      total_bs = pbGetCsvRecord($~[2],lineno,[1, "i", nil])
      total_bs = (total_bs / 10).to_i * 10
      movelist = pbGetCsvRecord($~[3],lineno,[2, "*e", :PBMoves])
      movepool[poke] = movelist
      stats[total_bs] = [] if !stats[total_bs]
      stats[total_bs].push(poke)
    end 
  }
  save_data(movepool,"Data/sclearned.dat")
  save_data(stats,"Data/scstattotals.dat")
end 



def scSaveLearnedMoves
  data = scLoadLearnedMoves
  speciesData = pbLoadSpeciesData
  return if !data || !speciesData
  
  File.open("PBS/sclearned.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    for poke in 1..PBSpecies.maxValueF
      line = getConstantName(PBSpecies,poke) + " = "
      if poke%50==0
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing learned moves (poke {1})...",poke))
      end
      
      next if !data[poke] && poke > PBSpecies.maxValue # Forms might not learn anything. 
      
      bs = speciesData[poke][SpeciesBaseStats].clone
      bs_sum = bs[0] + bs[1] + bs[2] + bs[3] + bs[4] + bs[5]
      line += bs_sum.to_s + ", "
      line += scConvertListToString(PBMoves, data[poke])
      
      f.write(line + "\r\n")
    end 
  }
end 



def scLoadLearnedMoves
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/sclearned.dat")
end



def scLoadStatTotals
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/scstattotals.dat")
end 


#===============================================================================
# Compile/decompile tiers
#===============================================================================

module SCTierData
  
  def self.extractType(line)
    return nil if line[0...5] != "Type:"
    line.gsub!(" ", "")
    line = line.split("=")
    line = line[0]
    line = line.split(":")
    line = line[1]
    line = line.split(",")
    types = []
    line.each { |t|
      types.push(pbGetCsvRecord(t,line,[1, "e", :PBTypes]))
    }
    return types
  end 
  
  InfoTypes = {
    "PokemonList"       => [0, "*e", :PBSpecies],
    "Name"              => [0, "s", nil],
    "Category"          => [0, "s", nil],
    "BannedAbilities"   => [0, "*e", :PBAbilities],
    "BannedItems"       => [0, "*e", :PBItems],
    "BannedMoves"       => [0, "*e", :PBMoves],
    "Stratum"           => [0, "i", nil]
  }
  
  def self.isListOfPokemons(sectionname)
    poke_lists = ["FrequentPokemons", "AllowedPokemons", "RarePokemons", "BannedPokemons"]
    return true if poke_lists.include?(sectionname)
    
    if self.extractType(sectionname)
      return true 
    else 
      return false 
    end 
  end 
  
  def self.generateTypedSections
    # So that compiler and decompiler show tiers with everything in the same order. 
    type_list = ["NORMAL", "FIGHTING", "FLYING", "POISON", 
          "GROUND", "ROCK", "BUG", "GHOST", "STEEL", 
          "FIRE", "WATER", "GRASS", "ELECTRIC", 
          "PSYCHIC", "ICE", "DRAGON", "DARK", "FAIRY"]
    
    typed_sections = []
    
    for t in type_list
      typed_sections.push("Type:" + t)
    end
    
    for t1 in type_list
      for t2 in type_list
        next if t1 == t2 
        typed_sections.push("Type:" + t1 + "," + t2)
      end
    end
    
    return typed_sections
  end 
  
end 



def scCompileTier
  tiers = {}
  tiers["TierList"] = [] # So the decompiler prints them in the same order as they were. 
  tierid = ""
  
  pbCompilerEachCommentedLine("PBS/sctiers.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/sctiers.txt (line {1})...",lineno))
    end
    if line[/^\s*\[\s*(\w+)\s*\]\s*$/]
      tierid = $~[1]
      tiers[tierid] = {"ID" => tierid}
      tiers["TierList"].push(tierid)
    elsif line[/^\s*([a-zA-Z\:\,]+)\s*=\s*(.*)$/]
      sectionname = $~[1]
      content = $~[2]
      
      if content != ""
        if SCTierData.isListOfPokemons(sectionname)
          tiers[tierid][sectionname] = pbGetCsvRecord(content,lineno,[0, "*e", :PBSpecies])
        else 
          schema = SCTierData::InfoTypes[sectionname]
          raise _INTL("Unknown section: {1}") if !schema
          tiers[tierid][sectionname] = pbGetCsvRecord(content,lineno,schema)
        end 
      else 
        tiers[tierid][sectionname] = []
      end 
    end 
  }
  save_data(tiers,"Data/sctiers.dat")
end 



def scSaveTier
  data=load_data("Data/sctiers.dat")
  return if !data
  
  typed_sections = SCTierData.generateTypedSections
  ordered_sections = ["FrequentPokemons", "RarePokemons", "AllowedPokemons", "BannedPokemons", "BannedAbilities", "BannedItems", "BannedMoves", "Name", "Category", "ID"]
  
  File.open("PBS/sctiers.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
		for tierid in data["TierList"]
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing tier {1}.",tierid))
      
			f.write("[" + tierid + "]\r\n")
      
      f.write("Name = " + data[tierid]["Name"] + "\r\n")
      f.write("Category = " + data[tierid]["Category"] + "\r\n")
      f.write("Stratum = " + data[tierid]["Stratum"].to_s + "\r\n") if data[tierid]["Stratum"]
      
      for sec in 0...4
        temp = scConvertListToString(PBSpecies, data[tierid][ordered_sections[sec]])
        f.write(ordered_sections[sec] + " = " + temp + "\r\n")
      end 
      
      temp = scConvertListToString(PBAbilities, data[tierid]["BannedAbilities"])
      f.write("BannedAbilities = " + temp + "\r\n")
      
      temp = scConvertListToString(PBItems, data[tierid]["BannedItems"])
      f.write("BannedItems = " + temp + "\r\n")
      
      temp = scConvertListToString(PBMoves, data[tierid]["BannedMoves"])
      f.write("BannedMoves = " + temp + "\r\n")
      
      # Type-specific stuff (for Bitype or Monotype)
      for sec in typed_sections
        next if !data[tierid].keys.include?(sec)
        
        # Avoid "The script is taking too long" error
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing tier {1} ({2}).",tierid, sec))
        
        temp = scConvertListToString(PBSpecies, data[tierid][sec])
        f.write(sec + " = " + temp + "\r\n")
      end 
    end 
  }
end 



def scConvertListToString(constant_type, the_list)
  line = ""
  for i in 0...the_list.length
    name = getConstantName(constant_type,the_list[i]) # rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
    next if !name
    line.concat(", ") if i>0
    line.concat(name)
  end
  return line 
end 


def scLoadTierData
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/sctiers.dat")
end 




#===============================================================================
# Compile/decompile personal items
#===============================================================================

module SCFormData 
  SPECIES = 0
  BASEFORM = 1
  FORM = 2
  OPTITEM = 3
  REQITEM = 4
  REQABILITY = 5
  REQMOVE = 6
  REQGENDER = 7
  REQNATURES = 8
  FORMNAME = 9
  BASESPECIES = 10
  MAXINDEX = 10
  
  InfoTypes = {
    "Pokemon"           => [SPECIES,      "e", :PBSpecies],   # Species, level
    "Form"              => [FORM,         "u"],
    "BaseForm"          => [BASEFORM,     "u"],
    "OptionalItem"      => [OPTITEM,      "e", :PBItems],
    "RequiredItem"      => [REQITEM,      "e", :PBItems],
    "RequiredMove"      => [REQMOVE,      "e", :PBMoves], # Several potneitla moves for the moveset 
    "RequiredAbility"   => [REQABILITY,   "e", :PBAbilities],
    "RequiredGender"    => [REQGENDER,    "e", { "M" => 0, "m" => 0, "Male" => 0, "male" => 0, "0" => 0,
                                                "F" => 1, "f" => 1, "Female" => 1, "female" => 1, "1" => 1 }],
    "RequiredNatures"   => [REQNATURES,   "*e", :PBNatures], # Toxtricity
    "FormName"          => [FORMNAME,     "s", nil] # Not used in the compiler, used in TeamBuilder. 
  }
  
  def self.newEmpty()
    return Array.new(MAXINDEX)
  end 
end 



def scCompilePersonalItems
  personal_items = {"order" => []}
  content = []
  species = -1 
  
  pbCompilerEachCommentedLine("PBS/scformreqs.txt") { |line,lineno|
    # Contains form requirements (for teambuilder) + personal items (e.g. THICKCLUB for MAROWAK)
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/scformreqs.txt (line {1})...",lineno))
    end
    if line[/^\s*(\w+)\s*=\s*(.*)$/]
      # XXX=YYY lines
      settingname = $~[1]
      schema = SCFormData::InfoTypes[settingname]
      next if !schema
      record = pbGetCsvRecord($~[2],lineno,schema)
      
      if settingname == "Pokemon"
        if species > 0
          # We are takcling a new Pokémon. 
          
          if content[SCFormData::BASEFORM]
            content[SCFormData::BASESPECIES] = pbGetFSpeciesFromForm(species, content[SCFormData::BASEFORM]) 
          elsif content[SCFormData::FORM]
            content[SCFormData::BASESPECIES] = pbGetFSpeciesFromForm(species, content[SCFormData::FORM])
          else 
            content[SCFormData::BASESPECIES] = species
          end 
          if personal_items[species]
            personal_items[species].push( content )
          else
            personal_items[species] = [ content ]
          end 
        end 
        content = SCFormData.newEmpty()
        species = record
        personal_items["order"].push(species) if !personal_items["order"].include?(species)
      end 
      content[schema[0]] = record
    end
  }
  if species > 0
    # The last Pokémon. 
    if personal_items[species]
      personal_items[species].push( content )
    else
      personal_items[species] = [ content ]
    end 
  end 
  save_data(personal_items,"Data/scformreqs.dat")
end 



def scSavePersonalItems
  data=load_data("Data/scformreqs.dat")
  return if !data
  
  File.open("PBS/scformreqs.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    data["order"].each do |pk|
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing form requirements for {1}.",pk))
      
      f.write("\#-------------------------------\r\n")
      
      for content in data[pk]
        f.write(_INTL("Pokemon = {1}\r\n", getConstantName(PBSpecies,pk)))
        f.write(_INTL("    BaseForm = {1}\r\n", content[SCFormData::BASEFORM])) if content[SCFormData::BASEFORM]
        f.write(_INTL("    Form = {1}\r\n", content[SCFormData::FORM])) if content[SCFormData::FORM]
        f.write(_INTL("    OptionalItem = {1}\r\n", getConstantName(PBItems,content[SCFormData::OPTITEM]))) if content[SCFormData::OPTITEM]
        f.write(_INTL("    RequiredItem = {1}\r\n", getConstantName(PBItems,content[SCFormData::REQITEM]))) if content[SCFormData::REQITEM]
        f.write(_INTL("    RequiredAbility = {1}\r\n", getConstantName(PBAbilities,content[SCFormData::REQABILITY]))) if content[SCFormData::REQABILITY]
        f.write(_INTL("    RequiredMove = {1}\r\n", getConstantName(PBMoves,content[SCFormData::REQMOVE]))) if content[SCFormData::REQMOVE]
        
        if content[SCFormData::REQGENDER]
          f.write(_INTL("    RequiredGender = Male\r\n")) if content[SCFormData::REQGENDER] == 0
          f.write(_INTL("    RequiredGender = Female\r\n")) if content[SCFormData::REQGENDER] == 1
        end 
        
        if content[SCFormData::REQNATURES]
          naturelist = ""
          for i in 0...content[SCFormData::REQNATURES].length
            naturelist += ", " if i > 0
            naturelist += getConstantName(PBNatures,content[SCFormData::REQNATURES][i])
          end 
          f.write(_INTL("    RequiredNatures = {1}\r\n", naturelist))
        end 
      end 
    end 
  }
end 



def scLoadPersonalItems(pkmn = nil)
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  data = load_data("Data/scformreqs.dat")
  
  if pkmn
    pkmn = pbGetSpeciesFromFSpecies(pkmn)[0]
    return data[pkmn] if pkmn
  end 
  return data
end 



def scLoadFormRequirements(pkmn = nil)
  return scLoadPersonalItems(pkmn)
end 


