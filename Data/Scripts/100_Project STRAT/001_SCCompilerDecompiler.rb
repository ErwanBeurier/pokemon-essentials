###############################################################################
# SCCompilerDecompiler
# 
# This script is part of Pokémon Project STRAT by StCooler, and is therefore 
# not part of Pokémon Essentials. 
# 
# This script contains everything related to the compilation and decompilation 
# of the datasets specific to Pokémon Project STRAT. 
# Note that all the PBS files mentionned here are generated by a Python script 
# that I won't share with the game (but you can ask me if you want).
# 
# -----------------------------------------------------------------------------
# Database of movesets: 
#   Compilation of PBS/movesets.txt
#   Decompilation of Data/movesets.dat
# Each Pokémon has a set of movesets, to be used by NPCs in random battle, or 
# by the player who doesn't want to spend time making a team.
# 
# -----------------------------------------------------------------------------
# Database of movepools:
#   Compilation of PBS/sclearned.txt
#   Decompilation of Data/sclearned.dat
# Each Pokémon is associated with the list of moves it can learn. This is 
# faster than checking the pokemon data + tm.dat and such in order to gather 
# the movepool of a given Pokémon. Used in Teambuilder, in the move selection.
# 
###############################################################################




#===============================================================================
# Compile/decompile movesets
#===============================================================================

module SCMovesetsMetadata
  SPECIES = 0 
  FORM = 1 
  ITEM = 2 
  MOVE1 = 3
  MOVE2 = 4
  MOVE3 = 5
  MOVE4 = 6
  ABILITY = 7
  GENDER = 8 
  NATURE = 9
  EV = 10
  IV = 11
  ROLE = 12
  SHINY = 13
  HAPPINESS = 14
  BALL = 15
  LEVEL = 16
  BASEFORM = 17
  NICKNAME = 18
  MAXINDEX = 18
  
  MovesIndices = {MOVE1 => "Move1", MOVE2 => "Move2", MOVE3 => "Move3", MOVE4 => "Move4"}
  MovesIndicesList = [MOVE1, MOVE2, MOVE3, MOVE4]
  
  def self.validRole(role)
    for i in 1..4
      # LEAD = 1
      # OFFENSIVE = 2
      # DEFENSIVE = 3
      # SUPPORT = 4
      for j in 0..3
        # PHYSICAL = 1 
        # SPECIAL = 2
        # MIXED = 3
        return true if role == i*10 + j
      end
    end
    return false 
  end 
  
  def self.emptyMoveset()
    return Array.new(MAXINDEX)
  end 
  
  InfoTypes = {
    "Pokemon"   => [SPECIES,   "ev", :PBSpecies,nil],   # Species, level
    "Form"      => [FORM,      "u"],
    "BaseForm"  => [BASEFORM,  "u"],
    "Item"      => [ITEM,      "*e", :PBItems], # Several potential items for the moveset
    "Move1"     => [MOVE1,     "*e", :PBMoves], # Several potneitla moves for the moveset 
    "Move2"     => [MOVE2,     "*e", :PBMoves], 
    "Move3"     => [MOVE3,     "*e", :PBMoves],
    "Move4"     => [MOVE4,     "*e", :PBMoves],
    "Ability"   => [ABILITY,   "u"],
    "Gender"    => [GENDER,    "e", { "M" => 0, "m" => 0, "Male" => 0, "male" => 0, "0" => 0,
                                      "F" => 1, "f" => 1, "Female" => 1, "female" => 1, "1" => 1 }],
    "Shiny"     => [SHINY,     "b"],
    "Nature"    => [NATURE,    "e", :PBNatures],
    "Nature1"   => [NATURE,    "e", :PBNatures],
    "Nature2"   => [NATURE,    "e", :PBNatures],
    "Nature3"   => [NATURE,    "e", :PBNatures],
    "Nature4"   => [NATURE,    "e", :PBNatures],
    "Nature5"   => [NATURE,    "e", :PBNatures],
    "Nature6"   => [NATURE,    "e", :PBNatures],
    "Nature7"   => [NATURE,    "e", :PBNatures],
    "Nature8"   => [NATURE,    "e", :PBNatures],
    "Nature9"   => [NATURE,    "e", :PBNatures],
    "IV"        => [IV,        "uUUUUU"],
    "Happiness" => [HAPPINESS, "u"],
    "Ball"      => [BALL,      "u"],
    "EV"        => [EV,        "uUUUUU"],
    "EV1"       => [EV,        "uUUUUU"],
    "EV2"       => [EV,        "uUUUUU"],
    "EV3"       => [EV,        "uUUUUU"],
    "EV4"       => [EV,        "uUUUUU"],
    "EV5"       => [EV,        "uUUUUU"],
    "EV6"       => [EV,        "uUUUUU"],
    "EV7"       => [EV,        "uUUUUU"],
    "EV8"       => [EV,        "uUUUUU"],
    "EV9"       => [EV,        "uUUUUU"],
    "Role"      => [ROLE,      "u"],
    "Name"      => [NICKNAME,  "s"]
  }
  
end 



def scCompileMovesets
  mLevel = PBExperience.maxLevel
  trainerindex    = -1
  trainers        = []
  pokemonindex    = -2
  movesets        = {}
  moveset         = SCMovesetsMetadata.emptyMoveset()
  moveset_natures = []
  moveset_ev_spreads = []
  pokemon_id      = -1 
  # movesets: species_id -> list of lists of values
  #                                 vvvvvvvvvvvvvvv
  #                                 List of values encoding the moveset. 
  pbCompilerEachCommentedLine("PBS/scmovesets.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/scmovesets.txt (line {1})...",lineno))
    end

    if line[/^\s*(\w+)\s*=\s*(.*)$/]
      # XXX=YYY lines
      settingname = $~[1]
      schema = SCMovesetsMetadata::InfoTypes[settingname]
      next if !schema
      record = pbGetCsvRecord($~[2],lineno,schema)
      # Error checking in XXX=YYY lines
      case settingname
      when "Pokemon"
        if record[1]>mLevel
          raise _INTL("Bad level: {1} (must be 1-{2})\r\n{3}",record[1],mLevel,FileLineData.linereport)
        end
        if pokemon_id > 0
          # Then new moveset. Store the current moveset. 
          moveset[SCMovesetsMetadata::NATURE] = moveset_natures if moveset_natures.length > 0 
          moveset[SCMovesetsMetadata::EV] = moveset_ev_spreads if moveset_ev_spreads.length > 0 
          
          moveset[SCMovesetsMetadata::SPECIES] = pokemon_id
          
          if movesets[pokemon_id]
            movesets[pokemon_id].push(moveset)
          else 
            movesets[pokemon_id] = [moveset]
          end 
          
          moveset         = SCMovesetsMetadata.emptyMoveset()
          moveset_natures = []
          moveset_ev_spreads = []
        end 
        pokemon_id = record[0]
        moveset[SCMovesetsMetadata::LEVEL] = record[1]
      when "Move1", "Move2", "Move3", "Move4"
        # debug_s = ""
        # for i in 0...record.length
          # debug_s += ", " if i > 0
          # debug_s += getConstantName(PBMoves,record[i])
        # end 
        # raise _INTL("{1} and {2}", record.length, debug_s)
        # raise _INTL("{1}", $~[2])
        record = [record] if record.is_a?(Integer)
        record.compact!
      when "Ability"
        if record>5
          raise _INTL("Bad ability flag: {1} (must be 0 or 1 or 2-5).\r\n{2}",record,FileLineData.linereport)
        end
      when "IV"
        record = [record] if record.is_a?(Integer)
        record.compact!
        for i in record
          next if i<=PokeBattle_Pokemon::IV_STAT_LIMIT
          raise _INTL("Bad IV: {1} (must be 0-{2})\r\n{3}",i,PokeBattle_Pokemon::IV_STAT_LIMIT,FileLineData.linereport)
        end
      when "EV", "EV1", "EV2", "EV3", "EV4", "EV5", "EV6", "EV7", "EV8", "EV9"
        record = [record] if record.is_a?(Integer)
        record.compact!
        for i in record
          next if i<=PokeBattle_Pokemon::EV_STAT_LIMIT
          raise _INTL("Bad EV: {1} (must be 0-{2})\r\n{3}",i,PokeBattle_Pokemon::EV_STAT_LIMIT,FileLineData.linereport)
        end
        evtotal = 0
        for i in 0...6
          evtotal += (i<record.length) ? record[i] : record[0]
        end
        if evtotal>PokeBattle_Pokemon::EV_LIMIT
          raise _INTL("Total EVs are greater than allowed ({1})\r\n{2}",PokeBattle_Pokemon::EV_LIMIT,FileLineData.linereport)
        end
        moveset_ev_spreads.push(record)
      when "Nature", "Nature1", "Nature2", "Nature3", "Nature4", "Nature5", "Nature6", "Nature7", "Nature8", "Nature9"
        moveset_natures.push(record)
      when "Happiness"
        if record>255
          raise _INTL("Bad happiness: {1} (must be 0-255)\r\n{2}",record,FileLineData.linereport)
        end
      when "Role"
        if !SCMovesetsMetadata.validRole(record)
          raise _INTL("Bad moveset role: {1} (must be integer X*10 + Y, X=1..4 and Y=1..3)\r\n{2}",record,FileLineData.linereport)
        end 
      when "Form"
        pokemon_id = pbGetFSpeciesFromForm(pokemon_id, record)
      end
      if schema[0] <= SCMovesetsMetadata::MAXINDEX
        moveset[schema[0]] = record
      end 
    end
  }
  if pokemon_id > 0
    # Then new moveset. Store the current moveset. 
    moveset[SCMovesetsMetadata::NATURE] = moveset_natures if moveset_natures.length > 0 
    moveset[SCMovesetsMetadata::EV] = moveset_ev_spreads if moveset_ev_spreads.length > 0 
    moveset[SCMovesetsMetadata::SPECIES] = pokemon_id
    
    if movesets[pokemon_id]
      movesets[pokemon_id].push(moveset)
    else 
      movesets[pokemon_id] = [moveset]
    end 
  end 
  save_data(movesets,"Data/scmovesets.dat")
end



def scSaveMovesets
  data = scLoadMovesetsData
  
  return if !data 
  File.open("PBS/scmovesets.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    total_movesets = data.keys.length
    processed = 0

    # data.each_pair { |poke, movesets|
    for poke in 1..PBSpecies.maxValueF
      processed += 1 
      
      if processed%5==0
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing moveset {1}/{2}...",processed, total_movesets))
      end
      
      movesets = data[poke]
      
      next if !movesets && poke > PBSpecies.maxValue
      
      f.write("\#-------------------------------\r\n")
      for moveset in movesets
        f.write(scConvertMovesetToString(moveset, true))
        # species = "" 
        # poke1 = pbGetSpeciesFromFSpecies(poke)
        # species = getConstantName(PBSpecies,poke1[0]) #rescue pbGetSpeciesConst(poke1[0]) rescue ""
        
        # f.write(sprintf("Pokemon = %s,%d\r\n",species,moveset[SCMovesetsMetadata::LEVEL]))
        
        # if moveset[SCMovesetsMetadata::FORM]
          # f.write(sprintf("    Form = %d\r\n",moveset[SCMovesetsMetadata::FORM]))
        # end
        # if moveset[SCMovesetsMetadata::BASEFORM]
          # f.write(sprintf("    BaseForm = %d\r\n",moveset[SCMovesetsMetadata::BASEFORM]))
        # end 
        # if moveset[SCMovesetsMetadata::ITEM] && moveset[SCMovesetsMetadata::ITEM].length>0
          # item = "" 
          # for i in 0...moveset[SCMovesetsMetadata::ITEM].length
            # itemname = getConstantName(PBItems,moveset[SCMovesetsMetadata::ITEM][i]) rescue pbGetItemConst(moveset[SCMovesetsMetadata::ITEM][i]) rescue nil
            # next if !itemname
            # item.concat(", ") if i>0
            # item.concat(itemname)
          # end 
          # f.write(sprintf("    Item = %s\r\n",item)) if item
        # end
        # for move_i in SCMovesetsMetadata::MovesIndicesList
          # move_s = SCMovesetsMetadata::MovesIndices[move_i]
          # if moveset[move_i] && moveset[move_i].length>0
            # movestring = ""
            # for i in 0...moveset[move_i].length
              # movename = getConstantName(PBMoves,moveset[move_i][i]) rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
              # next if !movename
              # movestring.concat(", ") if i>0
              # movestring.concat(movename)
            # end
            # f.write(sprintf("    " + move_s + " = %s\r\n",movestring)) if movestring!=""
          # end
        # end
        # if moveset[SCMovesetsMetadata::ABILITY]
          # f.write(sprintf("    Ability = %d\r\n",moveset[SCMovesetsMetadata::ABILITY]))
        # end
        # if moveset[SCMovesetsMetadata::NATURE]
          # for i in 0...moveset[SCMovesetsMetadata::NATURE].length
            # nature = getConstantName(PBNatures,moveset[SCMovesetsMetadata::NATURE][i]) rescue nil
            # f.write(sprintf("    Nature%d = %s\r\n",i+1, nature)) if nature
          # end 
        # end
        # if moveset[SCMovesetsMetadata::EV] && moveset[SCMovesetsMetadata::EV].length>0
          # ev_i = 1 
          # for ev_spread in moveset[SCMovesetsMetadata::EV]
            # f.write(sprintf("    EV%d = %d",ev_i, ev_spread[0]))
            # if ev_spread.length>1
              # for i in 1...6
                # f.write(sprintf(",%d",(i<ev_spread.length) ? ev_spread[i] : ev_spread[0]))
              # end
            # end
            # f.write("\r\n")
            # ev_i += 1 
          # end 
        # end
        # if moveset[SCMovesetsMetadata::IV] && moveset[SCMovesetsMetadata::IV].length>0
          # f.write(sprintf("    IV = %d",moveset[SCMovesetsMetadata::IV][0]))
          # if moveset[SCMovesetsMetadata::IV].length>1
            # for i in 1...6
              # f.write(sprintf(",%d",(i<moveset[SCMovesetsMetadata::IV].length) ? moveset[SCMovesetsMetadata::IV][i] : moveset[SCMovesetsMetadata::IV][0]))
            # end
          # end
          # f.write("\r\n")
        # end
        # if moveset[SCMovesetsMetadata::GENDER]
          # f.write(sprintf("    Gender = %s\r\n",(moveset[SCMovesetsMetadata::GENDER]==1) ? "female" : "male"))
        # end
        # if moveset[SCMovesetsMetadata::SHINY]
          # f.write("    Shiny = yes\r\n")
        # end
        # if moveset[SCMovesetsMetadata::HAPPINESS]
          # f.write(sprintf("    Happiness = %d\r\n",moveset[SCMovesetsMetadata::HAPPINESS]))
        # end
        # if moveset[SCMovesetsMetadata::BALL]
          # f.write(sprintf("    Ball = %d\r\n",moveset[SCMovesetsMetadata::BALL]))
        # end
        # if moveset[SCMovesetsMetadata::ROLE]
          # f.write(sprintf("    Role = %d\r\n",moveset[SCMovesetsMetadata::ROLE]))
        # end
      end 
    end
  }
end



def scLoadMovesetsData
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/scmovesets.dat")
end




def scConvertMovesetToString(moveset, with_tab = false)
# def getStringFromPkmn(poke, with_tab = false)
  s_tab = (with_tab ? "    " : "")
  
  poke1 = pbGetSpeciesFromFSpecies(moveset[SCMovesetsMetadata::SPECIES])
  species = getConstantName(PBSpecies,poke1[0]) #rescue pbGetSpeciesConst(poke1[0]) rescue ""
  
  s = _INTL("Pokemon = {1},{2}\r\n", species, moveset[SCMovesetsMetadata::LEVEL])
  
  if moveset[SCMovesetsMetadata::FORM]
    s += sprintf(s_tab + "Form = %d\r\n",moveset[SCMovesetsMetadata::FORM])
  end
  if moveset[SCMovesetsMetadata::BASEFORM]
    s += sprintf(s_tab + "BaseForm = %d\r\n",moveset[SCMovesetsMetadata::BASEFORM])
  end 
  
  if moveset[SCMovesetsMetadata::ITEM]
    if moveset[SCMovesetsMetadata::ITEM].is_a?(Array)
      item = "" 
      for i in 0...moveset[SCMovesetsMetadata::ITEM].length
        itemname = getConstantName(PBItems,moveset[SCMovesetsMetadata::ITEM][i]) rescue pbGetItemConst(moveset[SCMovesetsMetadata::ITEM][i]) rescue nil
        next if !itemname
        item.concat(", ") if i>0
        item.concat(itemname)
      end 
      s += sprintf(s_tab + "Item = %s\r\n",item) if item
      
    else 
      s += sprintf(s_tab + "Item = %s\r\n",getConstantName(PBItems,moveset[SCMovesetsMetadata::ITEM][i]))
    end 
  end
  
  for move_i in SCMovesetsMetadata::MovesIndicesList
    move_s = SCMovesetsMetadata::MovesIndices[move_i]
    if moveset[move_i] 
      if moveset[move_i].is_a?(Array)
        movestring = ""
        for i in 0...moveset[move_i].length
          movename = getConstantName(PBMoves,moveset[move_i][i]) rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
          next if !movename
          movestring.concat(", ") if i>0
          movestring.concat(movename)
        end
        s += sprintf(s_tab + "" + move_s + " = %s\r\n",movestring) if movestring!=""
        
      else 
        s += sprintf(s_tab + "" + move_s + " = %s\r\n",getConstantName(PBMoves,moveset[move_i]))
      end 
    end
  end
  
  if moveset[SCMovesetsMetadata::ABILITY]
    s += sprintf(s_tab + "Ability = %d\r\n",moveset[SCMovesetsMetadata::ABILITY])
  end
  
  if moveset[SCMovesetsMetadata::NATURE]
    if moveset[SCMovesetsMetadata::NATURE].is_a?(Array)
      for i in 0...moveset[SCMovesetsMetadata::NATURE].length
        nature = getConstantName(PBNatures,moveset[SCMovesetsMetadata::NATURE][i]) rescue nil
        s += sprintf(s_tab + "Nature%d = %s\r\n",i+1, nature) if nature
      end
    else 
      s += sprintf(s_tab + "Nature1 = %s\r\n", getConstantName(PBNatures,moveset[SCMovesetsMetadata::NATURE]))
    end 
  end
  
  if moveset[SCMovesetsMetadata::EV] && moveset[SCMovesetsMetadata::EV].length>0
    ev_i = 1 
    for ev_spread in moveset[SCMovesetsMetadata::EV]
      s += sprintf(s_tab + "EV%d = %d",ev_i, ev_spread[0])
      if ev_spread.length>1
        for i in 1...6
          s += sprintf(",%d",(i<ev_spread.length) ? ev_spread[i] : ev_spread[0])
        end
      end
      s += "\r\n"
      ev_i += 1 
    end 
  end
  
  if moveset[SCMovesetsMetadata::IV] && moveset[SCMovesetsMetadata::IV].length>0
    s += sprintf(s_tab + "IV = %d",moveset[SCMovesetsMetadata::IV][0])
    if moveset[SCMovesetsMetadata::IV].length>1
      for i in 1...6
        s += sprintf(",%d",(i<moveset[SCMovesetsMetadata::IV].length) ? moveset[SCMovesetsMetadata::IV][i] : moveset[SCMovesetsMetadata::IV][0])
      end
    end
    s += "\r\n"
  end
  
  if moveset[SCMovesetsMetadata::GENDER]
    s += sprintf(s_tab + "Gender = %s\r\n",(moveset[SCMovesetsMetadata::GENDER]==1) ? "female" : "male")
  end
  if moveset[SCMovesetsMetadata::SHINY]
    s += s_tab + "Shiny = yes\r\n"
  end
  if moveset[SCMovesetsMetadata::HAPPINESS]
    s += sprintf(s_tab + "Happiness = %d\r\n",moveset[SCMovesetsMetadata::HAPPINESS])
  end
  if moveset[SCMovesetsMetadata::BALL]
    s += sprintf(s_tab + "Ball = %d\r\n",moveset[SCMovesetsMetadata::BALL])
  end
  if moveset[SCMovesetsMetadata::ROLE]
    s += sprintf(s_tab + "Role = %d\r\n",moveset[SCMovesetsMetadata::ROLE])
  end
  
	# s = ""
	# hasmoves=(poke[3]!=0 || poke[4]!=0 || poke[5]!=0 || poke[6]!=0)
	# s += sprintf("%s,%d",pbGetSpeciesConst(poke[0]),poke[1])
	
	# if poke[2]!=0 || hasmoves || poke[7] || poke[8] || poke[9]!=0 || poke[10] ||
	# poke[11] || poke[12]!=10 || poke[13]!=70 || poke[14] || poke[15]
		# if poke[2].is_a?(Array)
			# # List.
			# temp = []
			# for t in poke[2]
				# temp.push(pbGetItemConst(t))
			# end 
			# s += sprintf(",%s",temp.join("+"))
		# else
			# s += ","
		# end
		# if hasmoves
			# extra=""
			# for i in 3...7
				# if poke[i] && poke[i]!=0
					# temp = []
					# for t in poke[i]
						# temp.push(pbGetMoveConst(t))
					# end 
					# s += sprintf(",%s",temp.join("+"))
				# else
					# extra+=","
				# end
			# end
			# s += extra
		# else
			# s += ",,,,"
		# end
		# s += ","+(poke[7] ? poke[7].to_s : "") # Ability 
		# s += ","+(poke[8] ? poke[8].to_s : "") # Gender 
		# s += ","+(poke[9] ? poke[9].to_s : "") # Form 
		# s += ","+(poke[10] ? "true" : "false") # Shiny 

		# # raise _INTL(poke[11])
		# if poke[11]
			# temp = []
			# for t in poke[11]
				# temp.push(getConstantName(PBNatures,t))
			# end 
			# s += sprintf(",%s",temp.join("+"))
		# else
			# s += ","
		# end
		# for k in 12...18 # IVs 
			# s += ","+(poke[k] ? poke[k].to_s : "")
		# end
		# for k in 18...24 # EVs 
			# if poke[k] && poke[k].is_a?(Array)
				# temp = []
				# for t in poke[k]
					# temp.push(t.to_s)
				# end 
				# s += sprintf(",%s",temp.join("+"))
			# elsif poke[k]
				# s += sprintf(",%s",poke[k].to_s)
			# else
				# s += ","
			# end

			# # f.write(","+(poke[k] ? poke[k].to_s : ""))
		# end
		# s += sprintf(",%s",poke[24]) # Happiness
		# s += sprintf(",%s",poke[25]) # Nickname  
		# s += ","+(poke[26] ? "true" : "false") # Shadow 
	# end
	
	return s 
end 




#===============================================================================
# Compile/decompile learned moves
#===============================================================================


def scCompileLearnedMoves
  movepool = {}
  pbCompilerEachCommentedLine("PBS/sclearned.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/sclearned.txt (line {1})...",lineno))
    end
    if line[/^\s*(\w+)\s*=\s*(.*)$/]
      poke = pbGetCsvRecord($~[1],lineno,[0, "e", :PBSpecies])
      movelist = pbGetCsvRecord($~[2],lineno,[1, "*e", :PBMoves])
      movepool[poke] = movelist
    end 
  }
  save_data(movepool,"Data/sclearned.dat")
end 


def scSaveLearnedMoves
  data = scLoadLearnedMoves
  return if !data 
  File.open("PBS/sclearned.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    for poke in 1..PBSpecies.maxValueF
      line = getConstantName(PBSpecies,poke) + " = "
      if poke%50==0
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing learned moves (poke {1})...",poke))
      end
      
      next if !data[poke] && poke > PBSpecies.maxValue # Forms might not learn anything. 
      
      # for i in 0...data[poke].length
        # movename = getConstantName(PBMoves,data[poke][i]) # rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
        # next if !movename
        # line.concat(", ") if i>0
        # line.concat(movename)
      # end
      line += scConvertListToString(PBMoves, data[poke])
      
      f.write(line + "\r\n")
    end 
  }
end 


def scLoadLearnedMoves
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  return load_data("Data/sclearned.dat")
end




#===============================================================================
# Compile/decompile tiers
#===============================================================================

module SCTiersData
  
  def self.extractType(line)
    return nil if line[0...5] != "Type:"
    line.gsub!(" ", "")
    line = line.split("=")
    line = line[0]
    line = line.split(":")
    line = line[1]
    line = line.split(",")
    types = []
    line.each { |t|
      types.push(pbGetCsvRecord(t,line,[1, "e", :PBTypes]))
    }
    return types
  end 
  
  InfoTypes = {
    "PokemonList"       => [0, "*e", :PBSpecies],
    "Name"              => [0, "s", nil],
    "Category"          => [0, "s", nil],
    "BannedAbilities"   => [0, "*e", :PBAbilities],
    "BannedItems"       => [0, "*e", :PBItems],
    "BannedMoves"       => [0, "*e", :PBMoves]
  }
  
  def self.isListOfPokemons(sectionname)
    poke_lists = ["FrequentPokemons", "AllowedPokemons", "RarePokemons", "BannedPokemons"]
    return true if poke_lists.include?(sectionname)
    
    if self.extractType(sectionname)
      return true 
    else 
      return false 
    end 
  end 
  
  def self.generateTypedSections
    # So that compiler and decompiler show tiers with everything in the same order. 
    type_list = ["NORMAL", "FIGHTING", "FLYING", "POISON", 
          "GROUND", "ROCK", "BUG", "GHOST", "STEEL", 
          "FIRE", "WATER", "GRASS", "ELECTRIC", 
          "PSYCHIC", "ICE", "DRAGON", "DARK", "FAIRY"]
    
    typed_sections = []
    
    for t in type_list
      typed_sections.push("Type:" + t)
    end
    
    for t1 in type_list
      for t2 in type_list
        next if t1 == t2 
        typed_sections.push("Type:" + t1 + "," + t2)
      end
    end
    
    return typed_sections
  end 
  
end 


def scCompileTiers
  tiers = {}
  tiers["TierList"] = [] # So the decompiler prints them in the same order as they were. 
  tierid = ""
  
  pbCompilerEachCommentedLine("PBS/sctiers.txt") { |line,lineno|
    if lineno%50==0
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing PBS/sctiers.txt (line {1})...",lineno))
    end
    if line[/^\s*\[\s*(\w+)\s*\]\s*$/]
      tierid = $~[1]
      tiers[tierid] = {"ID" => tierid}
      tiers["TierList"].push(tierid)
    elsif line[/^\s*([a-zA-Z\:\,]+)\s*=\s*(.*)$/]
      sectionname = $~[1]
      content = $~[2]
      
      if content != ""
        if SCTiersData.isListOfPokemons(sectionname)
          tiers[tierid][sectionname] = pbGetCsvRecord(content,lineno,[0, "*e", :PBSpecies])
        else 
          schema = SCTiersData::InfoTypes[sectionname]
          raise _INTL("Unknown section: {1}") if !schema
          tiers[tierid][sectionname] = pbGetCsvRecord(content,lineno,schema)
        end 
      else 
        tiers[tierid][sectionname] = []
      end 
    end 
  }
  save_data(tiers,"Data/sctiers.dat")
end 


def scSaveTiers
  data=load_data("Data/sctiers.dat")
  return if !data
  
  typed_sections = SCTiersData.generateTypedSections
  ordered_sections = ["FrequentPokemons", "RarePokemons", "AllowedPokemons", "BannedPokemons", "BannedAbilities", "BannedItems", "BannedMoves", "Name", "Category", "ID"]
  
  File.open("PBS/sctiers.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
		for tierid in data["TierList"]
      Graphics.update
      Win32API.SetWindowText(_INTL("Processing tiers {1}.",tierid))
      
			f.write("[" + tierid + "]\r\n")
      
      f.write("Name = " + data[tierid]["Name"] + "\r\n")
      f.write("Category = " + data[tierid]["Category"] + "\r\n")
      
      for sec in 0...4
        temp = scConvertListToString(PBSpecies, data[tierid][ordered_sections[sec]])
        f.write(ordered_sections[sec] + " = " + temp + "\r\n")
      end 
      
      temp = scConvertListToString(PBAbilities, data[tierid]["BannedAbilities"])
      f.write("BannedAbilities = " + temp + "\r\n")
      
      temp = scConvertListToString(PBItems, data[tierid]["BannedItems"])
      f.write("BannedItems = " + temp + "\r\n")
      
      temp = scConvertListToString(PBMoves, data[tierid]["BannedMoves"])
      f.write("BannedMoves = " + temp + "\r\n")
      
      # Type-specific stuff (for Bitype or Monotype)
      for sec in typed_sections
        next if !data[tierid].keys.include?(sec)
        
        # Avoid "The script is taking too long" error
        Graphics.update
        Win32API.SetWindowText(_INTL("Processing tiers {1} ({2}).",tierid, sec))
        
        temp = scConvertListToString(PBSpecies, data[tierid][sec])
        f.write(sec + " = " + temp + "\r\n")
      end 
    end 
  }
end 



def scConvertListToString(constant_type, the_list)
  line = ""
  for i in 0...the_list.length
    name = getConstantName(constant_type,the_list[i]) # rescue pbGetMoveConst(moveset[move_i][i]) rescue nil
    next if !name
    line.concat(", ") if i>0
    line.concat(name)
  end
  return line 
end 


#===============================================================================
# Compile/decompile personal items
#===============================================================================


def scCompilePersonalItems
  personal_items = {}
  
  pbCompilerEachCommentedLine("PBS/scpersonalitems.txt") { |line,lineno|
    if line[/^\s*(\w+)\s*,\s*(\w+)\s*,\s*(\w+)\s*,\s*(\w+)\s*$/]
      species = $~[1]
      item = $~[2]
      changes_form = $~[3]
      form = $~[4]
      species = pbGetCsvRecord(species,lineno,[0, "e", :PBSpecies])
      item = pbGetCsvRecord(item,lineno,[0, "e", :PBItems])
      changes_form = pbGetCsvRecord(changes_form,lineno,[0, "b", :PBSpecies])
      form = pbGetCsvRecord(form,lineno,[0, "u"])
      
      if personal_items[species]
        personal_items[species].push( [item ,changes_form, form] )
      else
        personal_items[species] = [ [item, changes_form, form] ]
      end 
    end
  }
  save_data(personal_items,"Data/scpersonalitems.dat")
end 


def scSavePersonalItems
  data=load_data("Data/scpersonalitems.dat")
  return if !data
  
  File.open("PBS/scpersonalitems.txt","wb") { |f|
    f.write("\# "+_INTL("This file is specific to Pokémon Project STRAT by StCooler. Generated by decompiler.\r\n"))
    
    for pk in data.keys
      # not in order but who the hell cares
      for itemlist in data[pk]
        s = getConstantName(PBSpecies,pk)
        s += "," + getConstantName(PBItems,itemlist[0])
        s += "," + (itemlist[1] ? "true" : "false")
        s += "," + itemlist[2].to_s 
        f.write(s + "\r\n")
      end 
    end 
  }
end 


def scLoadPersonalItems(pkmn = nil)
  # To be improved: 
  # $PokemonTemp = PokemonTemp.new if !$PokemonTemp
  # if !$PokemonTemp.trainersData
    # $PokemonTemp.trainersData = load_data("Data/trainers.dat") || []
  # end
  # return $PokemonTemp.trainersData
  data = load_data("Data/scpersonalitems.dat")
  return data[pkmn] if pkmn
  return data
end 

